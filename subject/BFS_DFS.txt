
저번에는 그래프구현, BFS, DFS

이번엔 알고리즘 구현!
총 5개의 알고리즘을 구현해야함


Minimum Spanning Tree(최소비용신장트리)

모든 노드가 다 연결이 되어있음
edge의 개수는 n-1개
weight가 있는 edge을땐 weight가 최소인 애를 찾는게 Minimum Spanning Tree 알고리즘이다 (최소비용신장트리)

n개의 노드에 선을 깔건데 어떻게 깔아야 비용이 가장 적게 들것인가! 에서 사용한다
즉 이 알고리즘은 Minimum Spanning Tree은 딱 하나로 정해져있음 답이 여러개가 아님!

사이클이 존재하면 안됨 (노드가 중복된다는 뜻)
노드(vertax)를 추가할때마다 이것을 추가함으로서 사이클이 생기는지 확인해야함

heap을 사용해 가중치를 오름차순으로 정렬
순환을 안만드는 edge를 추출
모두 연결될때까지 반복

- MP
바둑을 둘 때 최적의 위치를 찾는 알고리즘
을 찾기위해서는 시간이 굉장히 오래걸림
정답은 아니지만 가장 정답일 수 있는 수(최적)를 둠

사람은 경험에 의해 직감적으로 둠

+) 딥러닝(에드워드 스터디 열거니까 참여해주세요)
+) 수학을 공부하세여

- Prim알고리즘


- Kruskal알고리즘
Vertax n개에 edge가 n-1개
한 vertax를 선택하고 거기에 연결된 edge들중 가중치가 작은걸 선택함
근데그게 사이클을 형성하는건 안됨
그 edge를 따라 간 노드를 추가하면 시작노드와 새로추가한 노드 2개가됨
그 2노드가 연결된 모든 edge중에 weight가 가장 작은걸 선택
반복
그러면 최소비용신장트리가됨

최단경로 Shortest path
- dijkstra알고리즘
어디를 갈 때 가고자하는 곳까지 최단거리를 구하는 것

0 -(1)- 1 -(2)- 2 -(4)- 0
라면
0->2의 최단거리는 0->1->2가되어 답은 3임

V->W갈 때 원래 있는 거리보다 다른곳을 거쳐가는 거리가 더 짧다면 업데이트를 함

Cvw = v와 w사이의 거리
Yw = 원래 걸리던 거리
Yv = v까지 걸리는 거리

다이렉트 연결이 안되어있는 노드는 거리를 무한대로 해둠
무언가를 통해 가는 길을 다 찾음
단축거리가 기존거리보다 더 짧을때마다 업데이트를 함

*) 다른 연결이 없다면 기존에 찾은 단축거리를 이어서 사용할 수 있겠다 크게 의미 없나?

- Floyd알고리즘
모든노드에서 모든노드로갈때 모든노드를 거쳐가면 최단거리를 알 수 있는 알고리즘
n^3

##정렬
- Selection Sort
선택정렬
전체를 보고 가장작은걸 앞에두고
반복
On^2 걸림

- Bubble Sort
버블정렬
인덱스 1과 2를 비교후 큰걸 뒤로
2와 3을 비교후 큰걸 뒤로
사이클을 계속 돌면 정렬됨
On^2 걸림

- Quick Sort
퀵정렬
피봇이라는 기준을 두고 피봇을 제외한 애들을 보며 작은건 왼쪽 큰건 오른쪽에 둠
피봇을 제외하고 파티션이 생기면 또 피봇을 정함
O(nlog2N)
하지만 가장 큰 애를 피봇으로 선택하면
O(n^2) - 최악
최선, 평균, 최악의 경우가 있음

- 삽입정렬
가장 앞 노드를 정렬되어있는 하나의 노드라 가정
작으면 앞으로 크면 뒤로 넘김
2개의 노드가 정렬되어있음
이 이후론 들어갈 자리를 찾으며 정렬함
N ~ n^2

- 셸정렬
파티션을 줄이며 정렬함
평균 n^1.25
최악최선은 같음

- 병합정렬
Merge Sort
반 나눔
2개로 쪼개지면 정렬
4개에서정렬
합침
O(nlogn)

추가적인 메모리공간 필요, 이동횟수가많음

- 기수정렬
Radix Sort
O(d*n)
넣다뺄 버퍼가필요하다
횟수도 반복된다

- 히프정렬
저번에햇조?
O(nlogn)


정렬의 안정성 : 같은 값일때의 이야기 (움직이느냐 안움직이느냐)
한번 찾아보세요


---

key는 중복되면 안됨 
매칭되는 Value가 잇음
Key - yeju / value - cadet
value는 중복될 수 있음

key는 데이터를 찾는데 사용됨
~검색~
#해시태그 - key
나온 결과값 - value

Hasing검색 알고리즘
0 ~ 99의 좌석이 잇음
표를 팔았는데 자리가 꽉찬적이 없음!
표를 300개를 팔앗음
125번을 들고잇는 사람을 앉힌 후 찾기도 빨리하려면 25번에 앉힘
앉은 사람을 찾기까지const걸림

문제는 125번과 25번을 들고있는 사람이 충돌함

해싱은 구현안해두댐 

보통 75%정도쓰면 테이블을 뻥튀기함


2번정도 더 모이세호
전 끝낫습니다

내년에두PBL이나 스터디스케줄 올릴거니까 해야할거 하세용
42과정두 하셔야대요~~

컴퓨터사이언스에서 배워야하는것들이 잘 녹아져있어요
A가 B야 라고 알려주지 않기때문에
동료들과 함께 찾으세요
필로소퍼는 OS에요 데드락이자나요 - 그걸 공부할 때 
OS나 세마포어 공부는 할게 많아서 직접 문제를 두고 고민하고 구현하진 않아요
minishell은 시스템프로젝트잖아요 그건 한학기짜리예요

여기는 과제만있지 이론은 없잖아요
여러분이 이론을 찾아서 공부해야해여 한학기짜리만큼

이론을 잘 알고 (물어봤을때 알아야함)
미니셸을 물어밧는데 파이프를 모른다거나 필로소퍼를 했는데 데드락을 모른다거나
숙제가 아니라 공부를 해야합니다
고전을 공부할수 있는곳이에요
열심히하세요
2년을 굉장히 바쁘게 살아가야합니다

시간(돈)과 공간(42서울)을 드리니 열심히하세요








+) 좋은 알고리즘을 만들면 논문이 됨
+) 논문 == 이게 있었는데 이케하면 더좋음 / 이게 있었는데 난 이케함